[
  {
    "agent": "coder",
    "role": "gold",
    "task_description": "Implement a simple key-value store with get, set, delete, and list_keys methods. Data should be stored in memory with type hints and docstrings.",
    "output_snippet": "---FILE: store.py---\nfrom __future__ import annotations\n\n\nclass KeyValueStore:\n    \"\"\"Thread-unsafe in-memory key-value store.\"\"\"\n\n    def __init__(self) -> None:\n        self._data: dict[str, str] = {}\n\n    def get(self, key: str) -> str | None:\n        \"\"\"Retrieve a value by key, or None if missing.\"\"\"\n        return self._data.get(key)\n\n    def set(self, key: str, value: str) -> None:\n        \"\"\"Set a key to a value.\"\"\"\n        self._data[key] = value\n\n    def delete(self, key: str) -> bool:\n        \"\"\"Delete a key. Returns True if the key existed.\"\"\"\n        return self._data.pop(key, None) is not None\n\n    def list_keys(self) -> list[str]:\n        \"\"\"Return all keys in sorted order.\"\"\"\n        return sorted(self._data)\n---END---\n\n---FILE: test_store.py---\nimport pytest\nfrom store import KeyValueStore\n\n\ndef test_set_and_get():\n    store = KeyValueStore()\n    store.set(\"foo\", \"bar\")\n    assert store.get(\"foo\") == \"bar\"\n\n\ndef test_get_missing_key():\n    store = KeyValueStore()\n    assert store.get(\"nonexistent\") is None\n\n\ndef test_delete_existing():\n    store = KeyValueStore()\n    store.set(\"x\", \"1\")\n    assert store.delete(\"x\") is True\n    assert store.get(\"x\") is None\n\n\ndef test_delete_missing():\n    store = KeyValueStore()\n    assert store.delete(\"nope\") is False\n\n\ndef test_list_keys_sorted():\n    store = KeyValueStore()\n    store.set(\"c\", \"3\")\n    store.set(\"a\", \"1\")\n    store.set(\"b\", \"2\")\n    assert store.list_keys() == [\"a\", \"b\", \"c\"]\n---END---"
  },
  {
    "agent": "coder",
    "role": "gold",
    "task_description": "Create a CLI calculator that reads an expression from stdin and prints the result. Support +, -, *, / operators with proper error handling for division by zero and invalid input.",
    "output_snippet": "---FILE: calculator.py---\nfrom __future__ import annotations\n\nimport operator\nimport sys\n\nOPS: dict[str, callable] = {\n    \"+\": operator.add,\n    \"-\": operator.sub,\n    \"*\": operator.mul,\n    \"/\": operator.truediv,\n}\n\n\ndef evaluate(expression: str) -> float:\n    \"\"\"Evaluate a simple 'a op b' expression.\"\"\"\n    parts = expression.strip().split()\n    if len(parts) != 3:\n        raise ValueError(f\"Expected 'a op b', got: {expression!r}\")\n\n    left_str, op_str, right_str = parts\n\n    try:\n        left = float(left_str)\n        right = float(right_str)\n    except ValueError:\n        raise ValueError(f\"Invalid numbers: {left_str!r}, {right_str!r}\")\n\n    if op_str not in OPS:\n        raise ValueError(f\"Unknown operator: {op_str!r}. Supported: {', '.join(OPS)}\")\n\n    if op_str == \"/\" and right == 0:\n        raise ZeroDivisionError(\"Division by zero\")\n\n    return OPS[op_str](left, right)\n\n\ndef main() -> None:\n    if len(sys.argv) > 1:\n        expr = \" \".join(sys.argv[1:])\n    else:\n        expr = input(\"Expression: \")\n\n    try:\n        result = evaluate(expr)\n        print(f\"{result:g}\")\n    except (ValueError, ZeroDivisionError) as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n---END---\n\n---FILE: test_calculator.py---\nimport pytest\nfrom calculator import evaluate\n\n\ndef test_addition():\n    assert evaluate(\"2 + 3\") == 5.0\n\n\ndef test_subtraction():\n    assert evaluate(\"10 - 4\") == 6.0\n\n\ndef test_multiplication():\n    assert evaluate(\"3 * 7\") == 21.0\n\n\ndef test_division():\n    assert evaluate(\"15 / 3\") == 5.0\n\n\ndef test_division_by_zero():\n    with pytest.raises(ZeroDivisionError):\n        evaluate(\"1 / 0\")\n\n\ndef test_invalid_expression():\n    with pytest.raises(ValueError):\n        evaluate(\"just_a_word\")\n\n\ndef test_unknown_operator():\n    with pytest.raises(ValueError, match=\"Unknown operator\"):\n        evaluate(\"1 ^ 2\")\n---END---"
  },
  {
    "agent": "coder",
    "role": "gold",
    "task_description": "Implement a Task dataclass and a TaskManager that supports adding tasks, marking them complete, and filtering by status. Persist tasks to a JSON file.",
    "output_snippet": "---FILE: tasks.py---\nfrom __future__ import annotations\n\nimport json\nfrom dataclasses import asdict, dataclass, field\nfrom datetime import datetime\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    \"\"\"A single task item.\"\"\"\n    title: str\n    done: bool = False\n    created: str = field(default_factory=lambda: datetime.now().isoformat())\n\n\nclass TaskManager:\n    \"\"\"Manages a list of tasks with JSON persistence.\"\"\"\n\n    def __init__(self, path: Path | str = \"tasks.json\") -> None:\n        self._path = Path(path)\n        self._tasks: list[Task] = []\n        self._load()\n\n    def _load(self) -> None:\n        if self._path.exists():\n            data = json.loads(self._path.read_text())\n            self._tasks = [Task(**item) for item in data]\n\n    def save(self) -> None:\n        self._path.write_text(json.dumps([asdict(t) for t in self._tasks], indent=2))\n\n    def add(self, title: str) -> Task:\n        task = Task(title=title)\n        self._tasks.append(task)\n        self.save()\n        return task\n\n    def complete(self, index: int) -> None:\n        if 0 <= index < len(self._tasks):\n            self._tasks[index].done = True\n            self.save()\n        else:\n            raise IndexError(f\"No task at index {index}\")\n\n    def pending(self) -> list[Task]:\n        return [t for t in self._tasks if not t.done]\n\n    def completed(self) -> list[Task]:\n        return [t for t in self._tasks if t.done]\n\n    @property\n    def all(self) -> list[Task]:\n        return list(self._tasks)\n---END---"
  }
]
